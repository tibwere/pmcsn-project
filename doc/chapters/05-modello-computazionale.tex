\chapter{Modello computazionale}\label{chp:modello-computazionale}
L'approccio utilizzato per la realizzazione del modello computazionale è quello della next-event simulation. Di seguito è riportata un'analisi delle sue fasi.
\section{Stato del sistema}\label{sec:modello-computazionale-stato}
Le variabili di programma utilizzate per descrivere univocamente lo stato del sistema ad ogni istante di tempo sono:
\begin{itemize}
\item \texttt{{\color{code_purple} int} customers[NUMBER\_OF\_QUEUES]}: vettore di sei interi per la memorizzazione del numero di clienti per ciascuna tipologia di arrivo.
\item \texttt{{\color{code_purple} int} gen\_status[M-1]}: vettore di $M-1$ interi, che assumono valori in accordo alla definizione \ref{eqn:modello-specifiche-3}, per la memorizzazione dello stato dei serventi generali.
\item \texttt{{\color{code_purple} int} ded\_status}: intero, che assume valori in accordo alla definizione \ref{eqn:modello-specifiche-4}, per la memorizzazione dello stato del servente dedicato.
\end{itemize}

Il mapping fra le variabili matematiche definite nel modello delle specifiche e quelle di programma a livello computazionale è riassunto nella tabella \ref{table:modello-computazionale-1}. 

\begin{table}[ht]
\centering
{\tablecolors
\begin{tabular}{| l | l |}
\hline
Variabile matematica & Variabile di programma \\
\hline
$Customers_i(t)$ & \texttt{{\color{code_purple}int} customers[i]} \\
\hline
$Server_r(t)$ & \texttt{{\color{code_purple}int} gen\_status[r]} \\
\hline
$Server_\ded(t)$ & \texttt{{\color{code_purple}int} ded\_status} \\
\hline
\end{tabular}}
\caption{Mapping tra il modello delle specifiche e quello computazionale}
\label{table:modello-computazionale-1}
\end{table}
\newpage
Ad inizio simulazione lo stato del sistema viene impostato come segue:
\begin{center}
\begin{tabular}{l l l}
\texttt{customers[i]} & \texttt{=} & \texttt{0} \\
\texttt{gen\_status[j]} & \texttt{=} & \texttt{IDLE} \\
\texttt{ded\_status} & \texttt{=} & \texttt{IDLE}
\end{tabular}
\end{center}
per ogni $\mathtt{i\in \lbrace 0, 1, \dots, 5 \rbrace}$ e per ogni $\mathtt{j\in \lbrace 0, 1, \dots, M-2 \rbrace}$.

\section{Eventi}\label{sec:modello-computazionale-eventi}
Siano:
\begin{itemize}
\item $\mathtt{i \neq -1}$  l'indice che assume valori appartenenti alla terza colonna della tabella \ref{table:modello-specifiche-2}.
\item \texttt{r} l'indice che assume valori appartenenti all'insieme $\mathtt{\lbrace 0, 1, \dots, M - 2 \rbrace}$, utilizzato per accedere ai record dell'array \texttt{gen\_status}.
\end{itemize}
Lo stato del sistema può cambiare all'occorrenza delle seguenti tipologie di eventi propri:
\begin{itemize}
\item Sei tipologie d'arrivi, all'occorrenza dei quali:
\begin{center}
\texttt{customers[i] = customers[i] + 1}
\end{center}
\item Due tipologie di completamenti per ciascun server generale, a seguito dei quali:
\begin{itemize}
\item \texttt{gen\_status[r]} passa da un certo valore \texttt{i} ad \texttt{IDLE}
\item \texttt{customers[i] = customers[i] - 1}
\end{itemize}
\item Tre tipologie di completamenti per il server dedicato, per via dei quali:
\begin{itemize}
\item \texttt{ded\_status} passa da un certo valore \texttt{i} ad \texttt{IDLE}
\item \texttt{customers[i] = customers[i] - 1}
\end{itemize}
\end{itemize} 
\section{Clock di simulazione}\label{sec:modello-computazionale-clock}
L'orologio di sistema adottato nel simulatore è contenuto all'interno di una struttura dati\footnote{Nel codice viene adottata la variabile globale \texttt{{\color{code_purple}times\_t} t}.}, riportata nello snippet \ref{lst:modello-computazionale-1}, che memorizza informazioni relative al tempo di simulazione. In particolare:
\begin{itemize}
\item \texttt{{\color{code_purple}double} next}: istante di occorenza del successivo evento nel sistema.
\item \texttt{{\color{code_purple}double} last[NUMBER\_OF\_QUEUES]}: ciascuna entry \texttt{i} rappresenta l'istante dell'ultimo arrivo di tipo \texttt{i}.
\item \texttt{{\color{code_purple}double} current}: orologio di sistema.
\end{itemize}

\begin{lstlisting}[label={lst:modello-computazionale-1}, caption={Struttura dati per la gestione del tempo}]
typedef struct times {
    double next;                 	                                         
    double current;                	
    double last[NUMBER_OF_QUEUES];  
} times_t;
\end{lstlisting}

Di seguito sono riportate alcune osservazioni relative al tempo di simulazione:
\begin{itemize}
\item L'unità di misura di riferimento è il minuto.
\item L'orologio di sistema (\texttt{t->current}) viene inizializzato a \texttt{START}.
\item Il tempo di simulazione $\tau$ è pari a \texttt{STOP}.
\item Nel caso in cui l'istante $t^*$ d'occorrenza di un arrivo sia postumo al termine della simulazione ($t^* > \tau$), il successivo della medesima tipologia viene impostato pari a \texttt{INFTY} per denotare il blocco di tale flusso di arrivi (\textit{"close the door"}).
\end{itemize}
Per il caso di studio in analisi è stata adottata la seguente configurazione di parametri:
\begin{center}
\begin{tabular}{l c r}
\texttt{START = 0}, & \texttt{STOP = 480\footnotemark}, & \texttt{INFTY = 100 $\cdot$ STOP}
\end{tabular}
\footnotetext{Numero medio di minuti di una giornata lavorativa, calcolato a partire dalla \ref{eqn:modello-specifiche-15}.}
\end{center}
\section{Scheduler}\label{sec:modello-computazionale-scheduler}
Il meccanismo di avanzamento del tempo, che garantisce l'occorrenza ordinata degli eventi temporali, ad ogni iterazione del loop di simulazione:
\begin{enumerate}
\item Computa l'occorrenza del next-event (\texttt{t->next = next\_event(\dots)})
\item Aggiorna l'orologio di sistema (\texttt{t->current = t->next})
\end{enumerate}
fintantoché è verificata almeno una delle seguenti due condizioni:
\begin{itemize}
\item Il tempo di occorrenza degli eventi è non superiore a $\tau$.
\item Sono presenti clienti nel sistema non ancora serviti.
\end{itemize}

\section{Lista degli eventi}\label{sec:modello-computazionale-lista-eventi}
La lista degli eventi, a livello implementativo, è gestita mediante la struttura dati\footnote{Nel codice viene adottata la variabile globale \texttt{{\color{code_purple}event\_list\_t} events}.} riportata nello snippet \ref{lst:modello-computazionale-2}.
Ciascun campo della struttura mantiene gli istanti di tempo d'occorrenza per una categoria di eventi. In particolare:
\begin{itemize}
\item \texttt{{\color{code_purple}double} arrivals[NUMBER\_OF\_QUEUES]}: ciascuna entry \texttt{i} rappresenta l'istante del successivo arrivo di tipo \texttt{i}.
\item \texttt{{\color{code_purple}double} gen\_completions[M-1]}: ciascuna entry \texttt{r} rappresenta l'istante del successivo completamento del server \texttt{r}.
\item \texttt{{\color{code_purple}double} ded\_completion}: rappresenta l'istante del successivo completamento del server dedicato.
\end{itemize}

\begin{lstlisting}[label={lst:modello-computazionale-2}, caption={Struttura dati per la lista degli eventi}]
typedef struct event_list {
    double arrivals[NUMBER_OF_QUEUES];  
    double gen_completions[M-1];               
    double ded_completion;                         
} event_list_t; 
\end{lstlisting}

\section{Algoritmo next-event}\label{sec:modello-computazionale-algoritmo}
L'algoritmo di simulazione implementato consiste nei seguenti quattro passi:
\begin{enumerate}[label=Step \arabic*), align=left, leftmargin=*]
\item \textbf{Inizializzazione}
\begin{itemize}
\item L'orologio di simulazione è inizializzato come descritto nella sezione \ref{sec:modello-computazionale-clock}.
\item La lista degli eventi (\texttt{events}) è inizializzata determinando la prima occorrenza di ogni possibile evento. In particolare, per ogni $\mathtt{i \in \lbrace 0, 1, \dots, 5\rbrace}$:
\begin{center}
\begin{tabular}{l l l}
\texttt{events->arrivals[i]} & \texttt{=} & \texttt{GetArrival(i)} \\
\texttt{events->gen\_completions[i]} & \texttt{=} & \texttt{INFTY}
\end{tabular}
\end{center}
ed inoltre \texttt{events->ded\_completion = INFTY}
\end{itemize}
\item \textbf{Processamento evento corrente}
\begin{enumerate}
\item La lista degli eventi è scandita per determinare l'evento più imminente possibile, in accordo a quanto descritto nella sezione \ref{sec:modello-computazionale-scheduler}.
\item L'orologio di sistema viene avanzato al tempo di occorrenza dell'evento schedulato, in relazione a quanto proposto in sezione \ref{sec:modello-computazionale-scheduler}.
\item L'evento schedulato viene processato, come illustrato in sezione \ref{sec:modello-computazionale-eventi}.
\end{enumerate}
\item \textbf{Schedulazione nuovi eventi}
\begin{itemize}
\item Nel caso in cui l'evento corrente sia un arrivo di tipo $\mathtt{i \in \lbrace 0, 1, 2, 3 \rbrace}$:
\begin{itemize}
\item Se esiste almeno un servente generale \texttt{r} che è \texttt{IDLE}:
\begin{center}
\begin{tabular}{l l l}
\texttt{gen\_status[r]} & \texttt{=} & \texttt{i} \\
\texttt{events->gen\_completions[r]} & \texttt{=} & \texttt{t->current + GetService(i)}
\end{tabular}
\end{center}
\item Altrimenti, se il servente dedicato è \texttt{IDLE}:
\begin{center}
\begin{tabular}{l l l}
\texttt{ded\_status} & \texttt{=} & \texttt{i} \\
\texttt{ded\_completion} & \texttt{=} & \texttt{t->current + GetService(i)}
\end{tabular}
\end{center}
\end{itemize}
\item Nel caso in cui l'evento corrente sia un arrivo di tipo $\mathtt{i \in \lbrace 4, 5 \rbrace}$, se il servente dedicato è \texttt{IDLE}:
\begin{center}
\begin{tabular}{l l l}
\texttt{ded\_status} & \texttt{=} & \texttt{i} \\
\texttt{ded\_completion} & \texttt{=} & \texttt{t->current + GetService(i)}
\end{tabular}
\end{center}
\item Nel caso in cui l'evento corrente sia un completamento di tipo $\mathtt{i \in \lbrace 0, 1, 2, 3 \rbrace}$ da parte di un server generale \texttt{r}:
\begin{center}
\texttt{customers[i] = customers[i] - 1}
\end{center}
\begin{itemize}
\item Se esiste almeno una richiesta di tipo $\mathtt{j \in \lbrace 0, 1, 2, 3 \rbrace}$ in attesa di essere servita\footnote{\label{note:modello-computazionale-1}Nel caso in cui vi fossero più code non vuote, la priorità verrebbe data a quella con indice \texttt{j} minore.}:
\begin{center}
\begin{tabular}{l l l}
\texttt{gen\_status[r]} & \texttt{=} & \texttt{j} \\
\texttt{events->gen\_completions[r]} & \texttt{=} & \texttt{t->current + GetService(j)}
\end{tabular}
\end{center}
\item Altrimenti:
\begin{center}
\begin{tabular}{l l l}
\texttt{gen\_status[r]} & \texttt{=} & \texttt{IDLE} \\
\texttt{events->gen\_completions[r]} & \texttt{=} & \texttt{INFTY}
\end{tabular}
\end{center}
\end{itemize}
\item Nel caso in cui l'evento corrente sia un completamento di tipo $\mathtt{i \in \lbrace 0, \dots, 5 \rbrace}$ da parte del server dedicato:
\begin{center}
\texttt{customers[i] = customers[i] - 1}
\end{center}
\begin{itemize}
\item Se esiste almeno una richiesta di tipo $\mathtt{j \in \lbrace 4, 5 \rbrace}$ in attesa di essere servita\textsuperscript{\ref{note:modello-computazionale-1}}:
\begin{center}
\begin{tabular}{l l l}
\texttt{ded\_status} & \texttt{=} & \texttt{j} \\
\texttt{events->ded\_completion} & \texttt{=} & \texttt{t->current + GetService(j)}
\end{tabular}
\end{center}
\item Altrimenti, se esiste almeno una richiesta di tipo $\mathtt{j \in \lbrace 0, 1, 2, 3 \rbrace}$ in attesa di essere servita\textsuperscript{\ref{note:modello-computazionale-1}}:
\begin{center}
\begin{tabular}{l l l}
\texttt{ded\_status} & \texttt{=} & \texttt{j} \\
\texttt{events->ded\_completion} & \texttt{=} & \texttt{t->current + GetService(j)}
\end{tabular}
\end{center}
\item Altrimenti:
\begin{center}
\begin{tabular}{l l l}
\texttt{ded\_status} & \texttt{=} & \texttt{IDLE} \\
\texttt{events->ded\_completion} & \texttt{=} & \texttt{INFTY}
\end{tabular}
\end{center}
\end{itemize}
\end{itemize}
\item \textbf{Terminazione}
\begin{itemize}
\item L'evento artificiale che causa la terminazione della simulazione è l'intersezione dei seguenti:
\begin{itemize}
\item La prossima occorrenza di una qualsiasi tipologia di arrivo è postuma a $\tau$ (\texttt{events->arrivals[i] > STOP} per ogni \texttt{i}).
\item Non sono presenti richieste da processare (\texttt{customers[i] = 0} per ogni \texttt{i}).
\end{itemize}
\end{itemize}
\end{enumerate}