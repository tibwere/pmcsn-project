\chapter{Miglioria dell'algoritmo di schedulazione}
Nelle sezioni che seguono vengono ripercorsi i passi dell'algoritmo seguito nei capitoli precedenti, al fine di presentare le differenze introdotte a seguito dell'adozione del nuovo meccanismo di schedulazione.
\section{Presentazione del caso di studio}\label{sec:miglioria-presentazione}
La descrizione del caso di studio rimane pressoché inalterata, ad eccezione della presenza di alcune regole addizionali per la scelta dei ticket da servire.

Definiti:
\begin{itemize}
\item $A$ un cliente titolare di un conto \textsl{BancoPosta}, possessore di un ticket di tipo \uo{} o \pp{}.
\item $B$ un cliente \textbf{non} titolare di un conto \textsl{BancoPosta}, possessore di un ticket di tipo \uo{} o \pp{}.
\item $C$ un cliente possessore di un ticket di tipo \sr{}.
\end{itemize}
Di seguito, sono riportate le regole aggiuntive:
\begin{itemize}
\item Dopo un certo numero di clienti di tipo $A$ serviti, gli sportelli non dedicati devono necessariamente servire, se presenti, altri di tipo $B$, privilegiando la fila più lunga. 
\item Dopo un certo numero di clienti di tipo $C$ serviti, lo sportello dedicato deve necessariamente servire, se presenti, altri di tipo $B$, privilegiando la fila più lunga.
\item Nel caso in cui non vi siano clienti di tipo $C$ da servire, lo sportello dedicato dà priorità a quelli di tipo $B$, privilegiando la fila più lunga.
\end{itemize}
\section{Obiettivi dello studio}\label{sec:miglioria-obiettivi}
L'obiettivo di questo studio migliorativo è quello di diminuire, rispetto ai risultati precedentemente ottenuti, il numero degli sportelli da mantenere operativi in un'intera giornata lavorativa, continuando a garantire il rispetto dei requisiti di qualità stabiliti nel capitolo \ref{chp:obiettivi}.
\section{Modello concettuale}
Il modello concettuale proposto nel capitolo \ref{chp:modello-concettuale} continua ad essere rappresentativo anche a seguito dell'introduzione della miglioria. 

Pertanto:
\begin{itemize}
\item Le variabili che descrivono univocamente, ad ogni istante di tempo, lo stato del sistema
\item Le assunzioni alla base del modello concettuale
\end{itemize}
sono le medesime introdotte in tale capitolo.
\section{Modello delle specifiche}
Dal modello delle speficiche descritto nel capitolo \ref{chp:modello-specifiche}:
\begin{itemize}
\item Le variabili matematiche e le equazioni che le legano
\item Le assunzioni di base
\item I parametri di input del sistema
\end{itemize}
rimangono validi anche a seguito dell'introduzione della miglioria.

Considerando le regole di schedulazione addizionali espresse nella sezione \ref{sec:miglioria-presentazione}, gli algoritmi \ref{alg:modello-specifiche-1} e \ref{alg:modello-specifiche-2} sono stati rivisitati, applicando le opportune patch, come mostrato in \ref{alg:miglioria-modello-specifiche-1} e \ref{alg:miglioria-modello-specifiche-2}.

\begin{algorithm}[ht]
\SetAlgoLined
\While{true}{
\textcolor{purple}{\uIf{reached threshold}{
		\textit{pick the longest queue between \texttt{UNICA\_OP\_STD} and \texttt{PAGAM\_PREL\_STD}}\;
		\textit{processes the first ticket inside that queue}\;
	}}
	\uElseIf{\texttt{UNICA\_OP\_BP} queue not empty}{
		\textit{processes the first ticket of that type}\;
	}
	\uElseIf{\texttt{PAGAM\_PREL\_BP} queue not empty}{
		\textit{processes the first ticket of that type}\;
	}
	\uElseIf{\texttt{UNICA\_OP\_STD} queue not empty}{
		\textit{processes the first ticket of that type}\;
	}
	\uElseIf{\texttt{PAGAM\_PREL\_STD} queue not empty}{
		\textit{processes the first ticket of that type}\;
	}
}
\caption{Algoritmo di schedulazione del servente generico (con {\color{purple}patch})}
\label{alg:miglioria-modello-specifiche-1}
\end{algorithm}

\newpage

\begin{algorithm}
\While{true}{
	\textcolor{purple}{\uIf{reached threshold and there are tickets \texttt{UNICA\_OP\_STD} or \texttt{PAGAM\_PREL\_STD}}{
		\textit{pick the longest queue between \texttt{UNICA\_OP\_STD} and \texttt{PAGAM\_PREL\_STD}}\;
		\textit{processes the first ticket inside that queue}\;
	}}
	\uElseIf{\texttt{SPED\_RIT\_BP} queue not empty}{
		\textit{processes the first ticket of that type}\;
	}
	\uElseIf{\texttt{SPED\_RIT\_STD} queue not empty}{
		\textit{processes the first ticket of that type}\;
	}
	\textcolor{purple}{\uElseIf{there are tickets \texttt{UNICA\_OP\_STD} or \texttt{PAGAM\_PREL\_STD}}{
		\textit{pick the longest queue between them}\;
		\textit{processes the first ticket inside that queue}\;
	}}
	\uElseIf{\texttt{UNICA\_OP\_BP} queue not empty}{
		\textit{processes the first ticket of that type}\;
	}
	\uElseIf{\texttt{PAGAM\_PREL\_BP} queue not empty}{
		\textit{processes the first ticket of that type}\;
	}
}
\caption{Algoritmo di schedulazione del servente dedicato (con {\color{purple}patch})}
\label{alg:miglioria-modello-specifiche-2}
\end{algorithm}

\section{Modello computazionale}
Dal modello computazionale descritto nel capitolo \ref{chp:modello-computazionale}:
\begin{itemize}
\item Le variabili di programma (sez. \ref{sec:modello-computazionale-stato})
\item Gli eventi (sez. \ref{sec:modello-computazionale-eventi})
\item Il clock di simulazione (sez. \ref{sec:modello-computazionale-clock})
\item Scheduler (sez. \ref{sec:modello-computazionale-scheduler})
\item Lista degli eventi (sez. \ref{sec:modello-computazionale-lista-eventi})
\end{itemize}
rimangono validi anche a seguito dell'introduzione della miglioria.

\subsection{Algoritmo next-event}
Per la realizzazione della miglioria, a livello di codice, sono state definite due ulteriori variabili:
\begin{itemize}
\item \texttt{{\color{code_purple}int} counter\_served\_gen\_bp}: valore intero utilizzato per mantenere il numero di richieste di tipo \uo{} \textsl{BancoPosta} e \pp{} \textsl{BancoPosta} processate dai server generali.
\item \texttt{{\color{code_purple}int} counter\_served\_sr}: valore intero utilizzato per mantenere il numero di richieste di tipo \sr{} processate dal server dedicato.
\end{itemize}
Al fine di rendere efficace l'implementazione della miglioria, sono stati selezionati, tramite un approccio euristico, i seguenti valori soglia:
\begin{itemize}
\item \texttt{MAX\_CONT\_SERVED\_GEN\_BP = 7}, per la variabile \texttt{counter\_served\_gen\_bp}.
\item \texttt{MAX\_CONT\_SERVED\_SR = 3}, per la variabile \texttt{counter\_served\_sr}.
\end{itemize}
Di seguito, è riportato l'algoritmo di simulazione con le opportune modifiche (evidenziate in {\color{purple}viola}):
\begin{enumerate}[label=Step \arabic*), align=left, leftmargin=*]
\item \textbf{Inizializzazione}
\begin{itemize}
\item L'orologio di simulazione è inizializzato come descritto nella sezione \ref{sec:modello-computazionale-clock}.
\item La lista degli eventi (\texttt{events}) è inizializzata determinando la prima occorrenza di ogni possibile evento. In particolare:
\begin{center}
\begin{tabular}{l l l}
\texttt{events->arrivals[i]} & \texttt{=} & \texttt{GetArrival(i)} \\
\texttt{events->gen\_completions[i]} & \texttt{=} & \texttt{INFTY} \\
\texttt{events->ded\_completion} & \texttt{=} & \texttt{INFTY}
\end{tabular}
\end{center}
\end{itemize}
\item \textbf{Processamento evento corrente}
\begin{enumerate}
\item La lista degli eventi è scandita per determinare l'evento più imminente possibile, in accordo a quanto descritto nella sezione \ref{sec:modello-computazionale-scheduler}.
\item L'orologio di sistema viene avanzato al tempo di occorrenza dell'evento schedulato, in relazione a quanto proposto in sezione \ref{sec:modello-computazionale-scheduler}.
\item L'evento schedulato viene processato, come illustrato in sezione \ref{sec:modello-computazionale-eventi}.
\end{enumerate}
\item \textbf{Schedulazione nuovi eventi}
\begin{itemize}
\item Nel caso in cui l'evento corrente sia un arrivo di tipo $\mathtt{i \in \lbrace 0, 1, 2, 3 \rbrace}$:
\begin{itemize}
\item Se esiste almeno un servente generale \texttt{r} che è \texttt{IDLE}:
\begin{center}
\begin{tabular}{l l l}
\texttt{gen\_status[r]} & \texttt{=} & \texttt{i} \\
\texttt{events->gen\_completions[r]} & \texttt{=} & \texttt{t->current + GetService(i)}
\end{tabular}
\end{center}
\item Altrimenti, se il servente dedicato è \texttt{IDLE}:
\begin{center}
\begin{tabular}{l l l}
\texttt{ded\_status} & \texttt{=} & \texttt{i} \\
\texttt{ded\_completion} & \texttt{=} & \texttt{t->current + GetService(i)}
\end{tabular}
\end{center}
\item {\color{purple}Se $\mathtt{i \in \lbrace 0, 1 \rbrace}$, \texttt{counter\_served\_gen\_bp} viene settato a:
\begin{center}
\texttt{(counter\_served\_gen\_bp + 1) mod(MAX\_CONT\_SERVED\_GEN\_BP + 1)}\footnote{\label{note:miglioria-modello-computazionale-1}L'incremento modulare consente di resettare il contatore una volta superato il valore soglia. Ciò avviene solo quando le code relative a ticket di tipo \uo{} standard e \pp{} standard sono vuote e quindi non hanno bisogno di essere agevolate dal meccanismo introdotto dalla miglioria.}
\end{center}}
\end{itemize}

\item Nel caso in cui l'evento corrente sia un arrivo di tipo $\mathtt{i \in \lbrace 4, 5 \rbrace}$, se il servente dedicato è \texttt{IDLE}:
\begin{center}
\begin{tabular}{l l l}
\texttt{ded\_status} & \texttt{=} & \texttt{i} \\
\texttt{ded\_completion} & \texttt{=} & \texttt{t->current + GetService(i)}
\end{tabular}
\end{center}
{\color{purple}La variabile \texttt{counter\_served\_sr} viene settata a:
\begin{center}
\texttt{(counter\_served\_sr + 1) mod(MAX\_CONT\_SERVED\_SR + 1)}\textsuperscript{\ref{note:miglioria-modello-computazionale-1}}
\end{center}}
\item Nel caso in cui l'evento corrente sia un completamento di tipo $\mathtt{i \in \lbrace 0, 1, 2, 3 \rbrace}$ da parte di un server generale \texttt{r}:
\begin{center}
\texttt{customers[i] = customers[i] - 1}
\end{center}
\begin{itemize}
\item {\color{purple}Se la variabile \texttt{counter\_served\_gen\_bp} ha raggiunto il suo valore soglia ed esiste una richiesta pendente di tipo \uo{} standard o \pp{} standard:
\begin{center}
\begin{tabular}{l l l}
\texttt{q} & \texttt{=} & $\mathtt{\argmax_{j \in \lbrace 2, 3 \rbrace}{\left(queue[j]\right)}}$ \\
\texttt{gen\_status[r]} & \texttt{=} & \texttt{q} \\
\texttt{events->gen\_completions[r]} & \texttt{=} & \texttt{t->current + GetService(q)} \\
\texttt{counter\_served\_gen\_bp} & \texttt{=} & \texttt{0}
\end{tabular}
\end{center}}
\item {\color{purple}Altrimenti,} se esiste almeno una richiesta di tipo $\mathtt{j \in \lbrace 0, 1, 2, 3 \rbrace}$ in attesa di essere servita\footnote{\label{note:miglioria-modello-computazionale-2}Nel caso in cui vi fossero più code non vuote, la priorità verrebbe data a quella con indice \texttt{j} minore.}:
\begin{center}
\begin{tabular}{l l l}
\texttt{gen\_status[r]} & \texttt{=} & \texttt{j} \\
\texttt{events->gen\_completions[r]} & \texttt{=} & \texttt{t->current + GetService(j)}
\end{tabular}
\end{center}
{\color{purple}Se $\mathtt{j \in \lbrace 0, 1 \rbrace}$, \texttt{counter\_served\_gen\_bp} viene settato a:
\begin{center}
\texttt{(counter\_served\_gen\_bp + 1) mod(MAX\_CONT\_SERVED\_GEN\_BP + 1)}\textsuperscript{\ref{note:miglioria-modello-computazionale-1}}
\end{center}}
\item Altrimenti:
\begin{center}
\begin{tabular}{l l l}
\texttt{gen\_status[r]} & \texttt{=} & \texttt{IDLE} \\
\texttt{events->gen\_completions[r]} & \texttt{=} & \texttt{INFTY}
\end{tabular}
\end{center}
\end{itemize}
\item Nel caso in cui l'evento corrente sia un completamento di tipo $\mathtt{i \in \lbrace 0, \dots, 5 \rbrace}$ da parte del server dedicato:
\begin{center}
\texttt{customers[i] = customers[i] - 1}
\end{center}
\begin{itemize}
\item {\color{purple}Se la variabile \texttt{counter\_served\_sr} ha raggiunto il suo valore soglia ed esiste una richiesta pendente di tipo \uo{} standard o \pp{} standard:
\begin{center}
\begin{tabular}{l l l}
\texttt{q} & \texttt{=} & $\mathtt{\argmax_{j \in \lbrace 2, 3 \rbrace}{\left(queue[j]\right)}}$ \\
\texttt{ded\_status} & \texttt{=} & \texttt{q} \\
\texttt{events->ded\_completion} & \texttt{=} & \texttt{t->current + GetService(q)} \\
\texttt{counter\_served\_sr} & \texttt{=} & \texttt{0}
\end{tabular}
\end{center}}
\item {\color{purple}Altrimenti,} se esiste almeno una richiesta di tipo $\mathtt{j \in \lbrace 4, 5 \rbrace}$ in attesa di essere servita\textsuperscript{\ref{note:miglioria-modello-computazionale-2}}:
\begin{center}
\begin{tabular}{l l l}
\texttt{ded\_status} & \texttt{=} & \texttt{j} \\
\texttt{events->ded\_completion} & \texttt{=} & \texttt{t->current + GetService(j)} 
\end{tabular}
\end{center}
{\color{purple}La variabile \texttt{counter\_served\_sr} viene settata a:
\begin{center}
\texttt{(counter\_served\_sr + 1) mod(MAX\_CONT\_SERVED\_SR + 1)}\textsuperscript{\ref{note:miglioria-modello-computazionale-1}}
\end{center}}
\item {\color{purple}Altrimenti, se esiste almeno una richiesta di tipo $\mathtt{j \in \lbrace 2, 3 \rbrace}$ in attesa di essere servita\textsuperscript{\ref{note:miglioria-modello-computazionale-2}}:
\begin{center}
\begin{tabular}{l l l}
\texttt{q} & \texttt{=} & $\mathtt{\argmax_{j \in \lbrace 2, 3 \rbrace}{\left(queue[j]\right)}}$ \\
\texttt{ded\_status} & \texttt{=} & \texttt{q} \\
\texttt{events->ded\_completion} & \texttt{=} & \texttt{t->current + GetService(q)}
\end{tabular}
\end{center}}
\item {\color{purple}Altrimenti, se esiste almeno una richiesta di tipo $\mathtt{j \in \lbrace 0, 1 \rbrace}$ in attesa di essere servita\textsuperscript{\ref{note:miglioria-modello-computazionale-2}}:
\begin{center}
\begin{tabular}{l l l}
\texttt{ded\_status} & \texttt{=} & \texttt{j} \\
\texttt{events->ded\_completion} & \texttt{=} & \texttt{t->current + GetService(j)}
\end{tabular}
\end{center}
La variabile \texttt{counter\_served\_gen\_bp} viene settata a:
\begin{center}
\texttt{(counter\_served\_gen\_bp + 1) mod(MAX\_CONT\_SERVED\_GEN\_BP + 1)}\textsuperscript{\ref{note:miglioria-modello-computazionale-1}}
\end{center}}
\item Altrimenti:
\begin{center}
\begin{tabular}{l l l}
\texttt{ded\_status} & \texttt{=} & \texttt{IDLE} \\
\texttt{events->ded\_completion} & \texttt{=} & \texttt{INFTY}
\end{tabular}
\end{center}
\end{itemize}
\end{itemize}
\item \textbf{Terminazione}
\begin{itemize}
\item L'evento artificiale che causa la terminazione della simulazione è l'intersezione dei seguenti:
\begin{itemize}
\item La prossima occorrenza di una qualsiasi tipologia di arrivo è postuma a $\tau$ (\texttt{events->arrivals[i] > STOP} per ogni \texttt{i}).
\item Non sono presenti richieste da processare (\texttt{customers[i] = 0} per ogni \texttt{i}).
\end{itemize}
\end{itemize}
\end{enumerate}

\section{Verifica}
Da fare alle isole Tremiti

\section{Validazione}
Per la fase di validazione, è stato seguito lo stesso approccio mostrato nel capitolo \ref{chp:validazione}. Per semplicità, di seguito è riportata la configurazione dei parametri utilizzati per la simulazione:
\begin{itemize}
\item \texttt{B = 960}
\item \texttt{K = 64}
\item \texttt{STOP = 61440}
\item \texttt{STAT\_INIT\_SEED = 12345}
\end{itemize}
Inoltre, è stato utilizzato il programma \texttt{estimate} per il calcolo delle realizzazioni degli intervalli di confidenza.

\subsection{Blocco del flusso degli arrivi di tipo \sr{} e innalzamento valore soglia}
Privando il sistema della generazione di arrivi di tipo \sr{}, come mostrato in figura \ref{fig:validazione-semplificazione-1}, e inoltre:
\begin{itemize}
\item Fissando $M = 4$
\item Innalzando il valore soglia \texttt{MAX\_CONT\_SERVED\_GEN\_BP} a \texttt{1000}, per far sì che il meccanismo introdotto dalla miglioria non venga mai attivato
\end{itemize}
si ottengono i seguenti risultati:
\begin{itemize}
\item Mediante la simulazione:
\begin{itemize}
\item Il tempo medio d'attesa globale ottenuto è pari a:
\begin{equation} 
\bar{d}_g = \sum_{i = 1}^4 p_{g,i}\cdot \bar{d}_{g,i} = (7.81 \pm 1.11)\ min
\end{equation}
\item Il tempo medio di risposta globale ottenuto è pari a:
\begin{equation}
\bar{w}_g = \sum_{i = 1}^4 p_{g,i}\cdot \bar{w}_{g,i} = (22.90 \pm 1.32)\ min
\end{equation}
\end{itemize}

\item Mediante l'analisi effettuata in riferimento al modello a code riportato in figura \ref{fig:validazione-modello-analitico-1a}:
\begin{itemize}
\item Il tempo medio d'attesa globale ottenuto è pari a:
\begin{equation}
E[T_{Q_g}]^{KP} = 13.101566\ min 
\end{equation}
\item Il tempo medio di risposta globale ottenuto è pari a:
\begin{equation}
E[T_{S_g}] = 16.851566\ min 
\end{equation}
\end{itemize}
in accordo rispettivamente alle equazioni \ref{eqn:validazione-11} e \ref{eqn:validazione-13}.
\end{itemize}

I risultati ottenuti sono molto vicini a quelli della sezione \ref{sec:validazione-blocco-sr}, il che è ragionevole in quanto l'unica variazione tra il sistema privo di miglioria e quello in questione è dovuta al comportamento del server dedicato: la priorità maggiore è data alle richieste appartenenti alla coda più lunga tra quelle relative ai ticket di tipo \uo{} standard e \pp{} standard, piuttosto che assegnarla in modo inversamente proporzionale all'indice numerico della coda.

Poiché, anche in questo caso, l'occupazione media ottenuta tramite la simulazione è pari a:
\begin{equation}
\bar{x}_g = 0.77 \pm 0.02
\end{equation}
si ritengono ragionevoli i risultati ottenuti per i motivi descritti nella sezione \ref{sec:validazione-blocco-sr}.

\subsection{Blocco del flusso degli arrivi di tipo \uo{} e \pp{}}
Privando il sistema della generazione di arrivi di tipo \uo{} e \pp{}, come mostrato in figura \ref{fig:validazione-semplificazione-2} e fissando $M = 4$, si ottengono i seguenti risultati:
\begin{itemize}
\item Mediante la simulazione:
\begin{itemize}
\item Il tempo medio d'attesa globale ottenuto è pari a:
\begin{equation} 
\bar{d}_d = p_{d,1}\cdot \bar{d}_{d,1} + p_{d,2}\cdot \bar{d}_{d,2} = (17.61 \pm 3.77)\ min
\end{equation}
\item Il tempo medio di risposta globale ottenuto è pari a:
\begin{equation}
\bar{w}_d = p_{d,1}\cdot \bar{w}_{d,1} + p_{d,2}\cdot \bar{w}_{d,2} = (32.79 \pm 4.06)\ min
\end{equation}
\end{itemize}

\item Mediante l'analisi effettuata in riferimento al modello a code riportato in figura \ref{fig:validazione-modello-analitico-1b}:
\begin{itemize}
\item Il tempo medio d'attesa globale ottenuto è pari a:
\begin{equation}
E[T_{Q_d}]^{KP} = 18.245049\ min 
\end{equation}
\item Il tempo medio di risposta globale ottenuto è pari a:
\begin{equation}
E[T_{S_d}] = 33.245049\ min 
\end{equation}
\end{itemize}
in accordo rispettivamente alle equazioni \ref{eqn:validazione-24} e \ref{eqn:validazione-26}.
\end{itemize}

La congruenza dei risultati ottenuti con quelli della sezione \ref{sec:validazione-blocco-uo-pp} è una naturale conseguenza del fatto che il blocco di questi flussi fa in modo che il meccanismo introdotto dalla miglioria non venga mai attivato, motivo per cui non è stato necessario innalzare i valori soglia.

Per cui, poiché i valori teorici ricadono all'interno dei rispettivi intervalli con un livello di confidenza del 95\%, il comportamento del simulatore è, anche in questo caso, conforme al modello analitico \ref{fig:validazione-modello-analitico-1b}.

\section{Esperimenti di simulazione}
In accordo agli obiettivi dello studio (sez. \ref{sec:miglioria-obiettivi}), è stata considerata unicamente l'analisi dello stato transiente del sistema, per gli stessi motivi discussi nel capitolo \ref{chp:esperimenti-simulazione}.

\subsection{Progetto degli esperimenti}
Per realizzare l'esperimento di simulazione è stata adottata, anche in questo caso, la tecnica \textit{replication}. Per semplicità, di seguito è riportata la configurazione dei parametri utilizzati:
\begin{itemize}
\item \texttt{TERM\_INIT\_SEED = 9}
\item \texttt{ENSEMBLE\_SIZE = 300}
\item \texttt{START = 0}
\item \texttt{STOP = 480}
\end{itemize}

Inoltre:
\begin{itemize}
\item È stato utilizzato il programma \texttt{estimate} per il calcolo delle realizzazioni degli intervalli di confidenza.
\item È stato utilizzato il programma \texttt{uvs} per il calcolo di media e deviazione standard.
\end{itemize}

Dal capitolo \ref{chp:esperimenti-simulazione}, è stato individuato $M^* = 4$ come numero minimo di sportelli da mantenere operativi in una giornata lavorativa. Al fine di determinare un risultato più soddisfacente di quello precedentemente ottenuto, ovvero trovare $\accentset{\sim}{M} < M^*$ continuando a garantire gli stessi QoS (cap. \ref{chp:obiettivi}), è stata analizzata l'attesa media di ciascun flusso d'arrivo al variare di $M$, seguendo lo stesso approccio utilizzato in \ref{sec:esperimenti-simulazione-1}.

\subsection{Esecuzione degli esperimenti ed analisi degli output}
I risultati dell'esperimento condotto sono riportati sia in forma tabellare (tab. \ref{table:miglioria-esperimenti-simulazione-1}) che in forma grafica (fig. \ref{fig:miglioria-esperimenti-simulazione-1}).

È immediato osservare che, per raggiungere gli obiettivi precedentemente descritti, il numero minimo di serventi è $\accentset{\sim}{M} = 3$. Infatti, dalle figure \ref{fig:esperimenti-simulazione-1a}, \ref{fig:esperimenti-simulazione-1b}, \ref{fig:esperimenti-simulazione-1c} e \ref{fig:esperimenti-simulazione-1d}, si evince che con $M = 2$ non è possibile rispettare i corrispondenti QoS (in tabella \ref{table:miglioria-esperimenti-simulazione-1a} sono evidenziati in {\color{red}rosso} i valori di attesa che li superano).

\subsection{Grafici e tabelle}
\begin{table}[ht]
\centering
\begin{subtable}{0.33\textwidth}
\centering
{\tablecolors
\begin{tabular}{|c|c|c|}
\hline
$i$ & Media & Dev. std. \\
\hline
0 & {\color{red}25.377} & 12.256 \\
\hline
1 & {\color{red}79.039} & 61.215 \\
\hline
2 & {\color{red}216.057} & 78.006 \\
\hline
3 & {\color{red}358.342} & 110.317 \\
\hline
4 & 19.265 & 14.421 \\
\hline
5 & 48.454 & 34.731 \\
\hline
\end{tabular}}
\caption{$M = 2$}
\label{table:miglioria-esperimenti-simulazione-1a}
\end{subtable}%
\begin{subtable}{0.33\textwidth}
\centering
{\tablecolors
\begin{tabular}{|c|c|c|}
\hline
$i$ & Media & Dev. std. \\
\hline
0 & 8.690 & 4.086 \\
\hline
1 & 13.984 & 9.231 \\
\hline
2 & 48.015 & 33.204 \\
\hline
3 & 126.800 & 72.557 \\
\hline
4 & 18.161 & 11.651 \\
\hline
5 & 47.876 & 36.553 \\
\hline
\end{tabular}}
\caption{$M = 3$}
\end{subtable}%
\begin{subtable}{0.33\textwidth}
\centering
{\tablecolors
\begin{tabular}{|c|c|c|}
\hline
$i$ & Media & Dev. std. \\
\hline
0 & 3.830 & 2.359 \\
\hline
1 & 5.015 & 4.178 \\
\hline
2 & 10.169 & 8.748 \\
\hline
3 & 28.515 & 29.343 \\
\hline
4 & 15.978 & 12.133 \\
\hline
5 & 38.608 & 33.608 \\
\hline
\end{tabular}}
\caption{$M = 4$}
\end{subtable}
\caption{Attesa espressa in minuti, per ciascun flusso $i$, al variare di $M$}
\label{table:miglioria-esperimenti-simulazione-1}
\end{table}

\begin{figure}[ht]
\centering
\begin{subfigure}[b]{0.475\textwidth}
\centering
\includegraphics[width=\textwidth]{plots/d0-trans-imp}
\caption{\uo{} BP}
\label{fig:esperimenti-simulazione-1a}
\end{subfigure}
\hfill    
\begin{subfigure}[b]{0.475\textwidth}  
\centering 
\includegraphics[width=\textwidth]{plots/d1-trans-imp}
\caption{\pp{} BP}
\label{fig:esperimenti-simulazione-1b} 
\end{subfigure}

\vskip\baselineskip

\begin{subfigure}[b]{0.475\textwidth}   
\centering 
\includegraphics[width=\textwidth]{plots/d2-trans-imp}
\caption{\uo{} STD}
\label{fig:esperimenti-simulazione-1c}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.475\textwidth}   
\centering 
\includegraphics[width=\textwidth]{plots/d3-trans-imp}
\caption{\pp{} STD}
\label{fig:esperimenti-simulazione-1d}
\end{subfigure}

\vskip\baselineskip

\begin{subfigure}[b]{0.475\textwidth}   
\centering 
\includegraphics[width=\textwidth]{plots/d4-trans-imp}
\caption{\sr{} BP}    
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.475\textwidth}   
\centering 
\includegraphics[width=\textwidth]{plots/d5-trans-imp}
\caption{\sr{} STD}    
\end{subfigure}
\caption{Attesa espressa in minuti, per ciascun flusso, al variare di $M$}
\label{fig:miglioria-esperimenti-simulazione-1}
\end{figure}